{
	// Place your snippets for java here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"enum":{
		"description": "enum Template",
		"prefix": "enum",
		"body": [
			"public enum $1 {",
				"\tk${2:var0}(0),",
				"\tk${3:var1}(1),",
				"\tk${4:var2}(2);",
				"",
				"\t@SuppressWarnings(\"MemberName\")",
				"\tpublic final int value;",
				"",
				"\t$1(int value) {",
					"\t\tthis.value = value;",
				"\t}",
			"}",
		]
	},
	
	"Gyro NavX Imports":{
		"description": "Create Required Imports",
		"prefix": "Gyro NavX Imports",
		"body": [
			"import edu.wpi.first.wpilibj.DriverStation;",
			"import com.kauailabs.navx.frc.AHRS;",
		]
	},
	"Gyro NavX Definition":{
		"description": "Create the Class Definition",
		"prefix": "Gyro NavX Declare",
		"body": "public static AHRS ahrs;",
	},
	"Gyro NavX Instantiate":{
		"description": "Instantiate the Class",
		"prefix": "Gyro NavX Init",
		"body": [
			"",
			"",
			"//Create Gyro",
			"/******Must add      import edu.wpi.first.wpilibj.DriverStation;      *****/",
			"/******Must add      import com.kauailabs.navx.frc.AHRS;              *****/",
			"/******Must add      public static AHRS ahrs;                         *****/",
			"try {",
			"\tSystem.out.println(\"Hello Tying to INIT Navx\");",
			"\t/* Communicate w/navX MXP via the MXP SPI Bus.                                    */",
			"\t/* Alternatively:  I2C.Port.kMXP, SerialPort.Port.kMXP or SerialPort.Port.kUSB     */",
			"\t/* See http://navx-mxp.kauailabs.com/guidance/selecting-an-interface/ for details. */",
			"",
			"\t//ahrs = new AHRS(SPI.Port.kMXP);",
			"\t$1ahrs = new AHRS(I2C.Port.kMXP);",
			"\t//ahrs = new AHRS(SerialPort.Port.kUSB);",
			"\t//ahrs = new AHRS(I2C.Port.kOnboard);",
			"\t//ahrs = new AHRS(I2C.Port.kOnboard,(byte)200);",
			"",	
			"} catch (RuntimeException ex ) {",
			"\tSystem.out.println(\"Hello from the Navx runtimeExcept\");",
			"\tDriverStation.reportError(\"Error instantiating navX MXP:  \" + ex.getMessage(), true);",
			"}",
		]
	},
	"Gyro_adrxs450 Imports":{
		"description": "Create Required Imports",
		"prefix": "Gyro_adrxs450 Imports",
		"body": [
			"import edu.wpi.first.wpilibj.ADXRS450_Gyro;",
		]
	},
	"Gyro_adrxs450 Class":{
		"description": "Create the Class Definition",
		"prefix": "Gyro_adrxs450 Declare",
		"body": "public static ADXRS450_Gyro adrxs450_Gyro;",
	},
	"Gyro_adrxs450 Instantiate":{
		"description": "Instantiate the Class",
		"prefix": "Gyro adrxs450",
		"body": [
			"try{",
			"\tDriverStation.reportWarning(\"Init ADXRS450_Gyro\", false);",
			"\tadrxs450_Gyro = new ADXRS450_Gyro();",
			"}catch (RuntimeException ex ) {",
			"\tSystem.out.println(\"Hello from the adrxs450_Gyro runtimeExcept\");",
			"\tDriverStation.reportError(\"Error instantiating adrxs450_Gyro:  \" + ex.getMessage(), true);",
			"}",
		]
	},
	"Gyro Pigeon Imports":{
		"description": "Create Required Imports",
		"prefix": "Gyro Prgeon Improrts",
		"body": "import com.ctre.phoenix.sensors.*;"
	},
	"Gyro Pigeon Class":{
		"description": "Create the Class Definition",
		"prefix": "Gyro Pigeon Declare",
		"body": "PigeonIMU _pidgey;"
	},
	"Gyro Pigeon Instantiate":{
		"description": "Instantiate the Class",
		"prefix": "Gyro Pigeon",
		"body": [
			"/* choose which cabling method for Pigeon */",
			"//_pidgey = new PigeonImu(0); /* Pigeon is on CANBus (powered from ~12V, and has a device ID of zero */",
			"$1_pidgey = new PigeonIMU($2); /* Pigeon is ribbon cabled to the specified CANTalon. */",
		]	
	},
	"AutoChooser INT":{
		"description": "Creates an Auto chooser that returns a Integer value",
		"prefix": "AutoChooser <Integer>",
		"body": [
			"private void setup$1Chooser() {",
			"\t$1Chooser = new SendableChooser<>();",
			"",
			"\t$1Chooser.addDefault(\"$2\", 0);",
			"\t$1Chooser.addClass(\"#3\", 1);",
			"",
			"\tSmartDashboard.putData(\"$1 Chooser\", $1Chooser);",
			"}",
			"",
		]
	},
	"AutoChooser Command":{
		"description": "",
		"prefix": "AutoChooser <Command>",
		"body": [
			"private void setupAutomousChooser(){",
			"\t//Create the Auto Chooser",
			"\t//SmartDashboard.putString(\"autonomous Title\", \"Autonomous Choice\");",
			"\tautonomousChooser = new SendableChooser();",
			"",
			"\t// ******* Default Auto",
			"\tautonomousChooser.addDefault(\"99: $2\", new $2());",					
			"",
			"\t// ******* Basic Auto",
			"\tautonomousChooser.addClass(\"0: $3\", new $3());",
			"",
			"",
			"//Place autonomousChooser on the SmartDashboard",
			"SmartDashboard.putData(\"Autonomous Chooser\", autonomousChooser);",
			"}",
			"",	
		]
	},
	"Conditional Command Body":{
		"description": "",
		"prefix": "Conditional Command Body",
		"body": [
			"import ${1:CLASS_PATH}.Robot;",
			"import edu.wpi.first.wpilibj.DriverStation;",
			"import edu.wpi.first.wpilibj.command.ConditionalCommand;",
			"",
			"/**",
			"*",
			"*/",
			"public class $TM_FILENAME_BASE extends ConditionalCommand {",
			"",
			"\tpublic $TM_FILENAME_BASE() {",
			"\t\tsuper(new ${2:IF TRUE COMMAND}, new ${3:IF FALSE COMMAND});",
			"\t}",
			"",
			"\t@Override",
			"\tprotected boolean condition(){",
			"\t\tString s = Robot.gameData;",
			"\t\tString commandName = this.getName();",
			"\t\tDriverStation.reportError(\"RUNING: \" + commandName, false);",
			"\t\tif(s.length($4) > 0){",
			"\t\t\tif(s.charAt(${5:Position}) == '${6:value To Test'){",
			"\t\t\t\tDriverStation.reportError(\"${7:Game Data Is True}\", false);",
			"\t\t\t\treturn true;",
			"\t\t\t}else{",
			"\t\t\t\tDriverStation.reportError(\"${8:Game Data Is False}\", false);",
			"\t\t\treturn false;",
			"\t\t\t}",
			"\t\t}else {",
			"\t\t\tDriverStation.reportError(\"Game Data EMPTY\", false);",
			"\t\t\treturn false;",
			"\t\t}",
			"\t}",
			"}",
		]
	},
	"Lime Light Definition":{
		"description": "Create the Class Definition",
		"prefix": "Lime Light Declare",
		"body": "public static NetworkTable limeLighttable;",
	},
	"Lime Light Instantiate":{
		"description": "Instantiate the Class",
		"prefix": "Lime Light Init",
		"body": "limeLighttable = NetworkTableInstance.getDefault().getTable(\"limelight\");",
	},

	"Lime Light Subsystem":{
		"prefix": "Lime Light Subsystem",
		"description": "",
		"body": [
			"\tpublic enum LedMode {",
				"\t\tkon(0), koff(1), kblink(2);",
				"\t",
				"\t\t@SuppressWarnings(\"MemberName\")",
				"\t\tpublic final int value;",
				"\t",
				"\t\tLedMode(int value) {",
				"\t\t this.value = value;",
				"\t\t}",
				"\t}",
				"",
				"\tpublic enum CamMode {",
				"\t\tkvision(0), kdriver(1);",
				"\t",
				"\t\t@SuppressWarnings(\"MemberName\")",
				"\t\tpublic final int value;",
				"\t",
				"\t\tCamMode(int value) {",
				"\t\t this.value = value;",
				"\t\t}",
				"\t}",
				"",
				"\tpublic enum Stream {",
				"\t\tkStandard(0),",
				"\t\tkPiPMain(1),",
				"\t\tkPiPSecondary(2);",
				"\t",
				"\t\t@SuppressWarnings(\"MemberName\")",
				"\t\tpublic final int value;",
				"\t",
				"\t\tStream(int value) {",
				"\t\t\tthis.value = value;",
				"\t\t}",
				"\t}",
				"",
				"\t",
				"// Put methods for controlling this subsystem",
				"// here. Call these from Commands.",
				"",
				"\tprivate NetworkTable table = Robot.limeLighttable;",
				"\t//public void Vision_HardwareInit() {",
				"\t//  limeLighttable = NetworkTableInstance.getDefault().getTable(\"limelight\");",
				"\t//}",
				"",
				"public void initDefaultCommand() {",
				"// Set the default command for a subsystem here.",
				"//setDefaultCommand(new MySpecialCommand());",
				"}",
				"\t/**",
				"\t * tv   Whether the limelight has any valid targets (0 or 1)",
				"\t * @return",
				"\t */",
				"\tpublic boolean my_IsTargetFound() {",
				"\t\tNetworkTableEntry tv = table.getEntry(\"tv\");",
				"\tdouble v = tv.getDouble(0);",
				"\tif (v == 0.0f){",
				"\t\treturn false;",
				"\t}else {",
				"\t\treturn true;",
				"\t}",
				"\t}",
				"\t/**",
				"\t * tx Horizontal Offset From Crosshair To Target (-27 degrees to 27 degrees)",
				"\t * @return",
				"\t */",
				"public double my_degRotationToTarget() {",
				"\t\tNetworkTableEntry tx = Robot.limeLighttable.getEntry(\"tx\");",
				"\tdouble x = tx.getDouble(0.0);",
				"\treturn x;",
				"\t}",
				"\t/**",
				"\t * ty Vertical Offset From Crosshair To Target (-20.5 degrees to 20.5 degrees)",
				"\t * @return ",
				"\t */",
				"\tpublic double my_degVerticalToTarget() {",
				"\t\tNetworkTableEntry ty = Robot.limeLighttable.getEntry(\"ty\");",
				"\tdouble y = ty.getDouble(0.0);",
				"\treturn y;",
				"}",
				"\t/**",
				"\t * ta Target Area (0% of image to 100% of image)",
				"\t * @return",
				"\t */",
				"\tpublic double my_TargetArea() {",
				"\t\tNetworkTableEntry ta = Robot.limeLighttable.getEntry(\"ta\");",
				"\tdouble a = ta.getDouble(0.0);",
				"\treturn a;",
				"}",
				"\t/**",
				"\t * ts Skew or rotation (-90 degrees to 0 degrees)",
				"\t * @return",
				"\t */",
				"\tpublic double my_Skew_Rotation() {",
				"\t\tNetworkTableEntry ts = Robot.limeLighttable.getEntry(\"ts\");",
				"\tdouble s = ts.getDouble(0.0);",
				"\treturn s;",
				"\t}",
				"\t/**",
				"\t * tl The pipeline’s latency contribution (ms) Add at least 11ms for image capture latency.",
				"\t * @return",
				"\t */",
				"\tpublic double my_PipelineLatency() {",
				"\t\tNetworkTableEntry tl = Robot.limeLighttable.getEntry(\"tl\");",
				"\tdouble l = tl.getDouble(0.0);",
				"\treturn l;",
				"}",
				"",
				"\t//Setters",
				"\t",
				"\t/**",
				"\t * LedMode  Sets limelight’s LED state",
				"\t * ",
				"\t * 0 on",
				"\t * 1 off",
				"\t * 2 blink",
				"\t * @param ledMode",
				"\t */",
				"\tpublic void setLEDMode(double ledMode){",
				"\t\ttable.getEntry(\"ledMode\").setValue(ledMode);",
				"\t}",
				"\t/**",
				"\t * camMode  Sets limelight’s operation mode",
				"\t * ",
				"\t * 0\tVision processor",
				"\t * 1\tDriver Camera (Increases exposure, disables vision processing)",
				"\t * @param camMode",
				"\t */",
				"\tpublic void setCamMode(double camMode) {",
				"\t\ttable.getEntry(\"camMode\").setValue(camMode);",
				"\t}",
				"\t/**",
				"\t * pipeline Sets limelight’s current pipeline",
				"\t * ",
				"\t * 0 .. 9   Select pipeline 0..9",
				"\t * ",
				"\t * @param pipeline",
				"\t */",
				"\tpublic void setPipeline(Double pipeline) {",
				"\t\ttable.getEntry(\"pipeline\").setValue(pipeline);",
				"\t}",
				"",
				"\t/**",
				"\t * stream   Sets limelight’s streaming mode",
				"\t * ",
				"\t * 0\tStandard - Side-by-side streams if a webcam is attached to Limelight",
				"\t * 1\tPiP Main - The secondary camera stream is placed in the lower-right corner of the primary camera stream",
				"\t * 2\tPiP Secondary - The primary camera stream is placed in the lower-right corner of the secondary camera stream",
				"\t * ",
				"\t * @param stream",
				"\t */ ",
				"\tpublic void setStream(Double stream) {",
				"\t\ttable.getEntry(\"stream\").setValue(stream);",
				"\t}",
				"",
				"\t/**",
				"\t * snapshot Allows users to take snapshots during a match",
				"\t * ",
				"\t * 0\tStop taking snapshots",
				"\t * 1\tTake two snapshots per second",
				"\t * @param snapshot",
				"\t */",
				"\tpublic void setSnapshot(Double snapshot) {",
				"\t\ttable.getEntry(\"snapshot\").setValue(snapshot);",
				"\t}",
				"",
				"\t// *************** Advanced Usage with Raw Contours *********************   ",
				"",
				"\t/**",
				"\t * Limelight posts three raw contours to NetworkTables that are not influenced by your grouping mode. ",
				"\t * That is, they are filtered with your pipeline parameters, but never grouped. X and Y are returned ",
				"\t * in normalized screen space (-1 to 1) rather than degrees.\t * ",
				"\t */",
				"",
				"\tpublic double Advanced_RotationToTarget(int raw) {",
				"\t\tNetworkTableEntry txRaw = Robot.limeLighttable.getEntry(\"tx\" + Integer.toString(raw));",
				"\tdouble x = txRaw.getDouble(0.0);",
				"\treturn x;",
				"\t}",
				"",
				"\tpublic double Advanced_degVerticalToTarget(int raw) {",
				"\t\tNetworkTableEntry tyRaw = Robot.limeLighttable.getEntry(\"ty\" + Integer.toString(raw));",
				"\tdouble y = tyRaw.getDouble(0.0);",
				"\treturn y;",
				"\t}",
				"",
				"\tpublic double Advanced_TargetArea(int raw) {",
				"\t\tNetworkTableEntry taRaw = Robot.limeLighttable.getEntry(\"ta\" + Integer.toString(raw));",
				"\tdouble a = taRaw.getDouble(0.0);",
				"\treturn a;",
				"}",
				"\t",
				"\tpublic double Advanced_Skew_Rotation(int raw) {",
				"\t\tNetworkTableEntry tsRaw = Robot.limeLighttable.getEntry(\"ts\" + Integer.toString(raw));",
				"\tdouble s = tsRaw.getDouble(0.0);",
				"\treturn s;",
				"\t}",
				"",
				"\t//Raw Crosshairs:",
				"\t//If you are using raw targeting data, you can still utilize your calibrated crosshairs:",
				"\t",
				"\tpublic double[] Advanced_RawCrosshair(int raw){",
				"\t\tdouble[] crosshars = new double[2];",
				"\t\tcrosshars[0] = Advanced_RawCrosshair_X(raw);",
				"\t\tcrosshars[1] = Advanced_RawCrosshair_Y(raw);",
				"\t\treturn crosshars;",
				"\t\t",
				"\t}",
				"\tpublic double Advanced_RawCrosshair_X(int raw) {",
				"\t\tNetworkTableEntry cxRaw = Robot.limeLighttable.getEntry(\"cx\" + Integer.toString(raw));",
				"\tdouble x = cxRaw.getDouble(0.0);",
				"\treturn x;",
				"\t}",
				"",
				"\tpublic double Advanced_RawCrosshair_Y(int raw) {",
				"\t\tNetworkTableEntry cyRaw = Robot.limeLighttable.getEntry(\"cy\" + Integer.toString(raw));",
				"\tdouble y = cyRaw.getDouble(0.0);",
				"\treturn y;",
				"\t}",
				"",
				
		]


	}
}